---
layout: post
status: publish
published: true
title: 汉诺塔JS实现
author:
  display_name: 北漂IT民工
  login: admin
  email: calidion@gmail.com
  url: ''
author_login: admin
author_email: calidion@gmail.com
wordpress_id: 1579
wordpress_url: http://www.3gcnbeta.com/wordpress/?p=1579
date: !binary |-
  MjAxMy0wOS0wNSAyMTo1MDoxMyArMDgwMA==
date_gmt: !binary |-
  MjAxMy0wOS0wNSAxMzo1MDoxMyArMDgwMA==
categories:
- Javascript
tags: []
comments: []
---
<p>汉诺塔是一个比较经典的递归问题。由于其包含两层递归，所以相对来讲比较难理解。<br />
同时一些书本上只给出来算法。并没有真正的可以运行并且包含数据处理的例子。<br />
今天兴趣一来，就写了一个。<br />
放在博客上，留做纪念。</p>
<p>汉诺塔问题描述：</p>
<p>共有3根杆子，在初始的杆子上，有n个圆盘，这些圆盘从下至上按照从大到小的顺序排列。</p>
<p>现在要把这些原盘移动到第三根杆子上，<br />
要求，每次移动只能移动一个圆盘，而且大的圆盘不能放到小的圆盘上面。</p>
<pre language="js" name="code">
var namespace = {};<br />
(function(namespace) {</p>
<p>var a = [], b = [], c = [];</p>
<p>function hanoi(x, y, z, n) {<br />
	if (n === 1) {<br />
		move(x, z);<br />
	} else {<br />
		console.log("move n -1 from x to y , level " + n);<br />
		hanoi(x, z, y, n - 1);<br />
		console.log(a);<br />
		console.log(b);<br />
		console.log(c);<br />
		console.log("move x to y , level " + n);<br />
		move(x, z);<br />
		console.log(a);<br />
		console.log(b);<br />
		console.log(c);<br />
		console.log("move n - 1 from y to z , level " + n);<br />
		hanoi(y, x, z, n - 1);<br />
		console.log(a);<br />
		console.log(b);<br />
		console.log(c);<br />
	}<br />
}</p>
<p>function move(x, y) {<br />
	var v = x.pop();<br />
	console.log(v);<br />
	y.push(v);<br />
}</p>
<p>function start_hanoi(n) {<br />
	a = [];<br />
	b = [];<br />
	c = [];</p>
<p>	for ( var i = n; i > 0; i--) {<br />
		a.push(i);<br />
	}<br />
	console.log(a);</p>
<p>	hanoi(a, b, c, n);</p>
<p>	console.log(c);<br />
}</p>
<p>namespace.hanoi = start_hanoi;</p>
<p>})(namespace);</p>
<p>namespace.hanoi(1);<br />
<&#47;pre></p>
